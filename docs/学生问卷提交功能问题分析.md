# 学生问卷提交功能问题分析与解决方案

## 问题分析

### 问题1：教师端看不到学生提交的数据

**原因：**
- 学生提交问卷时，后端创建的 `SurveyResponse` 状态是 `"submitted"`
- 教师端查询结果时，过滤条件是 `SurveyResponse.status == 'completed'`
- 状态不匹配，导致教师端看不到提交数据

**相关代码位置：**
- 学生提交：`backend/app/api/student/survey.py` 第 242 行
  ```python
  resp = SurveyResponseModel(
      survey_id=UUID(survey_id),
      student_id=sid,
      attempt_number=attempt,
      status="submitted",  # ← 这里状态是 "submitted"
      submit_time=datetime.utcnow(),
  )
  ```

- 教师查询：`backend/app/api/teacher/survey.py` 第 488 行
  ```python
  responses = db.query(SurveyResponse).filter(
      SurveyResponse.survey_id == survey_id,
      SurveyResponse.status == 'completed'  # ← 这里过滤的是 "completed"
  ).all()
  ```

### 问题2：学生可以重复答已完成的问卷

**原因：**
- 后端没有检查学生是否已经提交过问卷
- 每次提交都会创建新的 `SurveyResponse` 记录
- 没有根据问卷的 `allow_multiple_attempts` 和 `max_attempts` 字段进行限制

**相关代码位置：**
- `backend/app/api/student/survey.py` 第 229-238 行
  ```python
  existing = (
      db.query(SurveyResponseModel)
      .filter(
          SurveyResponseModel.survey_id == survey_id,
          SurveyResponseModel.student_id == sid,
      )
      .order_by(SurveyResponseModel.attempt_number.desc())
      .first()
  )
  attempt = (existing.attempt_number + 1) if existing else 1
  # ← 没有检查是否允许多次作答
  ```

### 问题3：缺少自动评分功能

**原因：**
- 学生提交答案后，没有自动评分
- 客观题（选择题、判断题）应该自动计算分数
- 主观题（问答题）需要教师手动评分

**相关代码位置：**
- `backend/app/api/student/survey.py` 第 248-256 行
  ```python
  answers = submission.answers or {}
  for qid, ans in answers.items():
      from app.models.survey import Answer as AnswerModel
      a = AnswerModel(
          response_id=resp.id,
          question_id=UUID(qid),
          student_answer=ans,
          # ← 没有设置 is_correct 和 score 字段
      )
      db.add(a)
  ```

---

## 需要实现的功能

### 1. 修复状态不一致问题

**方案1：修改学生提交时的状态（推荐）**

修改 `backend/app/api/student/survey.py` 第 242 行：
```python
# 修改前
resp = SurveyResponseModel(
    survey_id=UUID(survey_id),
    student_id=sid,
    attempt_number=attempt,
    status="submitted",  # 改为 "completed"
    submit_time=datetime.utcnow(),
)

# 修改后
resp = SurveyResponseModel(
    survey_id=UUID(survey_id),
    student_id=sid,
    attempt_number=attempt,
    status="completed",  # ← 改为 "completed"
    submit_time=datetime.utcnow(),
)
```

**方案2：修改教师查询时的过滤条件**

修改 `backend/app/api/teacher/survey.py` 第 488 行：
```python
# 修改前
responses = db.query(SurveyResponse).filter(
    SurveyResponse.survey_id == survey_id,
    SurveyResponse.status == 'completed'
).all()

# 修改后
responses = db.query(SurveyResponse).filter(
    SurveyResponse.survey_id == survey_id,
    SurveyResponse.status.in_(['submitted', 'completed'])  # ← 包含两种状态
).all()
```

### 2. 实现答题次数限制

**需要修改 `backend/app/api/student/survey.py` 的提交接口：**

```python
@router.post("/{survey_id}/submit")
async def submit_survey(
    survey_id: str,
    submission: SurveySubmission,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    提交问卷答案。会写入 survey_responses 与 answers；若已有提交记录则更新或按 attempt 追加。
    """
    if getattr(current_user, "role", None) != "student":
        raise HTTPException(status_code=403, detail="只有学生可以访问此接口")
    
    survey = db.query(SurveyModel).filter(SurveyModel.id == survey_id).first()
    if not survey or survey.status != "published":
        raise HTTPException(status_code=404, detail="问卷不存在或未发布")
    
    # 检查学生是否有权限访问该问卷
    class_ids = _get_student_class_ids(db, str(current_user.id))
    target_ids = getattr(survey, "target_class_ids", None) or []
    legacy_class_id = getattr(survey, "class_id", None)
    visible = (target_ids and any(str(cid) in class_ids for cid in (target_ids if isinstance(target_ids, list) else []))) or (
        legacy_class_id and str(legacy_class_id) in class_ids
    )
    if not visible:
        raise HTTPException(status_code=404, detail="问卷不存在或未发布")
    
    from datetime import datetime
    from uuid import UUID
    try:
        sid = current_user.id if hasattr(current_user.id, 'hex') else UUID(str(current_user.id))
    except Exception:
        sid = UUID(str(current_user.id))
    
    # 检查是否允许多次作答
    if not survey.allow_multiple_attempts:
        # 不允许多次作答，检查是否已经提交过
        existing = db.query(SurveyResponseModel).filter(
            SurveyResponseModel.survey_id == survey_id,
            SurveyResponseModel.student_id == sid,
        ).first()
        if existing:
            raise HTTPException(
                status_code=400,
                detail="该问卷不允许多次作答，您已经提交过了"
            )
    else:
        # 允许多次作答，检查是否超过最大次数
        existing_attempts = db.query(SurveyResponseModel).filter(
            SurveyResponseModel.survey_id == survey_id,
            SurveyResponseModel.student_id == sid,
        ).count()
        if existing_attempts >= survey.max_attempts:
            raise HTTPException(
                status_code=400,
                detail=f"您已达到最大作答次数（{survey.max_attempts}次）"
            )
    
    # 计算尝试次数
    existing = (
        db.query(SurveyResponseModel)
        .filter(
            SurveyResponseModel.survey_id == survey_id,
            SurveyResponseModel.student_id == sid,
        )
        .order_by(SurveyResponseModel.attempt_number.desc())
        .first()
    )
    attempt = (existing.attempt_number + 1) if existing else 1
    
    # 创建问卷响应记录
    resp = SurveyResponseModel(
        survey_id=UUID(survey_id),
        student_id=sid,
        attempt_number=attempt,
        status="completed",  # ← 修改为 "completed"
        submit_time=datetime.utcnow(),
    )
    db.add(resp)
    db.flush()
    
    # 保存答案并自动评分
    answers = submission.answers or {}
    total_score = 0
    for qid, ans in answers.items():
        from app.models.survey import Answer as AnswerModel
        
        # 获取题目信息
        question = db.query(QuestionModel).filter(
            QuestionModel.id == UUID(qid)
        ).first()
        
        if not question:
            continue
        
        # 自动评分（仅对客观题）
        is_correct = False
        score = 0
        
        if question.question_type in ['single_choice', 'judgment']:
            # 单选题和判断题
            correct_answer = question.correct_answer
            if correct_answer:
                if isinstance(correct_answer, list):
                    is_correct = ans in correct_answer
                else:
                    is_correct = ans == correct_answer
                if is_correct:
                    score = float(question.score)
        elif question.question_type == 'multiple_choice':
            # 多选题
            correct_answer = question.correct_answer
            if correct_answer and isinstance(ans, list):
                # 检查答案是否完全匹配
                if isinstance(correct_answer, list):
                    is_correct = set(ans) == set(correct_answer)
                else:
                    is_correct = ans == correct_answer
                if is_correct:
                    score = float(question.score)
        
        total_score += score
        
        # 创建答案记录
        a = AnswerModel(
            response_id=resp.id,
            question_id=UUID(qid),
            student_answer=ans,
            is_correct=is_correct,
            score=score,
            auto_graded=True,  # 标记为自动评分
        )
        db.add(a)
    
    # 更新问卷响应的总分
    resp.total_score = total_score
    resp.percentage_score = (total_score / survey.total_score * 100) if survey.total_score > 0 else 0
    resp.is_passed = resp.percentage_score >= survey.pass_score if survey.pass_score else None
    
    db.commit()
    
    return {
        "message": "问卷提交成功",
        "survey_id": survey_id,
        "total_score": total_score,
        "percentage_score": resp.percentage_score,
        "is_passed": resp.is_passed
    }
```

### 3. 实现学生查看答题结果

**前端需要修改 `frontend/src/pages/student/Survey/Detail.tsx`：**

```typescript
// 在页面加载时获取答题结果
useEffect(() => {
    if (!surveyId) return
    
    // 获取问卷详情
    studentSurveyApi.getSurveyDetail(surveyId)
        .then((data: any) => setSurvey(data))
        .catch((e: any) => setError(e.response?.data?.detail || e.message || '加载失败'))
        .finally(() => setLoading(false))
    
    // 获取答题结果
    studentSurveyApi.getMyResult(surveyId)
        .then((result: any) => {
            if (result.submitted) {
                setSubmitted(true)
                setScore(result.totalScore)
                setPercentageScore(result.percentageScore)
                setIsPassed(result.isPassed)
                setSubmitTime(result.submitTime)
            }
        })
        .catch((e: any) => {
            console.error('获取答题结果失败:', e)
        })
}, [surveyId])
```

### 4. 教师端手动评分功能

**需要添加教师评分接口：**

在 `backend/app/api/teacher/survey.py` 中添加：

```python
@router.post("/{survey_id}/responses/{response_id}/grade")
async def grade_response(
    survey_id: str,
    response_id: str,
    grading_data: Dict[str, float],  # {question_id: score}
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    """
    教师手动评分（用于主观题）
    """
    survey = db.query(Survey).filter(Survey.id == survey_id).first()
    if not survey:
        raise HTTPException(status_code=404, detail="问卷不存在")
    
    if str(survey.teacher_id) != str(current_user.id):
        raise HTTPException(status_code=403, detail="只有问卷创建者可以评分")
    
    response = db.query(SurveyResponse).filter(
        SurveyResponse.id == response_id,
        SurveyResponse.survey_id == survey_id
    ).first()
    
    if not response:
        raise HTTPException(status_code=404, detail="答题记录不存在")
    
    # 更新每道题的分数
    total_score = 0
    for question_id, score in grading_data.items():
        answer = db.query(Answer).filter(
            Answer.response_id == response_id,
            Answer.question_id == UUID(question_id)
        ).first()
        
        if answer:
            answer.score = score
            answer.is_correct = score > 0
            answer.graded_by = current_user.id
            answer.graded_at = datetime.utcnow()
            total_score += score
    
    # 更新总分
    response.total_score = total_score
    response.percentage_score = (total_score / survey.total_score * 100) if survey.total_score > 0 else 0
    response.is_passed = response.percentage_score >= survey.pass_score if survey.pass_score else None
    
    db.commit()
    
    return {"message": "评分成功", "total_score": total_score}
```

### 5. 前端显示学生已提交状态

**需要修改 `frontend/src/pages/student/Survey/index.tsx`：**

```typescript
// 在获取问卷列表时，检查每个问卷的提交状态
const loadSurveys = async () => {
    setIsLoadingSurveys(true)
    try {
        const raw = await surveyApi.getSurveys()
        const data = Array.isArray(raw) ? raw : (raw?.data ?? raw?.surveys ?? [])
        if (!Array.isArray(data)) {
            setSurveys([])
            return
        }
        
        // 检查每个问卷的提交状态
        const surveysWithStatus = await Promise.all(
            data.map(async (survey: any) => {
                try {
                    const result = await studentSurveyApi.getMyResult(survey.id)
                    return {
                        ...survey,
                        submitted: result.submitted,
                        totalScore: result.totalScore,
                        isPassed: result.isPassed
                    }
                } catch {
                    // 未提交过，返回未提交状态
                    return {
                        ...survey,
                        submitted: false
                    }
                }
            })
        )
        
        setSurveys(surveysWithStatus)
    } catch (error: any) {
        console.error('获取问卷列表失败:', error)
        alert(error.response?.data?.detail || '获取问卷列表失败')
    } finally {
        setIsLoadingSurveys(false)
    }
}
```

---

## 实施步骤

### 第1步：修复状态不一致问题
- [ ] 修改 `backend/app/api/student/survey.py` 第 242 行，将状态改为 `"completed"`
- [ ] 测试学生提交问卷
- [ ] 验证教师端能看到提交数据

### 第2步：实现答题次数限制
- [ ] 修改 `backend/app/api/student/survey.py` 的提交接口
- [ ] 添加不允许多次作答的检查
- [ ] 添加最大作答次数的检查
- [ ] 测试重复提交场景

### 第3步：实现自动评分
- [ ] 修改 `backend/app/api/student/survey.py` 的提交接口
- [ ] 添加单选题自动评分逻辑
- [ ] 添加判断题自动评分逻辑
- [ ] 添加多选题自动评分逻辑
- [ ] 更新问卷响应的总分和及格状态
- [ ] 测试自动评分功能

### 第4步：实现学生查看结果
- [ ] 修改 `frontend/src/pages/student/Survey/Detail.tsx`
- [ ] 添加获取答题结果的逻辑
- [ ] 显示分数和及格状态
- [ ] 测试学生查看结果功能

### 第5步：实现教师手动评分
- [ ] 在 `backend/app/api/teacher/survey.py` 添加评分接口
- [ ] 实现主观题评分逻辑
- [ ] 更新总分和及格状态
- [ ] 测试教师评分功能

### 第6步：前端显示提交状态
- [ ] 修改 `frontend/src/pages/student/Survey/index.tsx`
- [ ] 添加提交状态检查
- [ ] 显示已提交的问卷标记
- [ ] 防止重复提交已完成的问卷

---

## 测试验证

### 测试用例1：学生提交问卷
**测试步骤：**
1. 学生登录
2. 进入问卷列表
3. 选择一个问卷并开始答题
4. 完成所有题目
5. 提交问卷

**预期结果：**
- [ ] 提交成功
- [ ] 显示分数（客观题自动评分）
- [ ] 教师端能看到提交数据
- [ ] 学生无法重复提交（如果不允许多次作答）

### 测试用例2：教师查看结果
**测试步骤：**
1. 教师登录
2. 进入问卷管理
3. 点击"查看结果"

**预期结果：**
- [ ] 显示所有提交的学生
- [ ] 显示统计数据（平均分、及格率等）
- [ ] 显示每道题的正确率
- [ ] 显示学生答案

### 测试用例3：答题次数限制
**测试步骤：**
1. 学生提交问卷
2. 尝试再次提交同一问卷

**预期结果：**
- [ ] 如果不允许多次作答，提示已提交过
- [ ] 如果允许多次作答但超过最大次数，提示已达到最大次数
- [ ] 如果在限制内，允许再次提交

---

## 总结

**核心问题：**
1. 状态不一致：学生提交用 `"submitted"`，教师查询用 `"completed"`
2. 缺少答题次数限制
3. 缺少自动评分功能
4. 缺少学生查看结果功能

**解决方案：**
1. 统一状态为 `"completed"`
2. 添加答题次数检查逻辑
3. 实现客观题自动评分
4. 实现学生查看结果功能
5. 实现教师手动评分功能（用于主观题）

**优先级：**
- 高优先级：修复状态不一致（问题1）
- 高优先级：实现答题次数限制（问题2）
- 中优先级：实现自动评分（问题3）
- 中优先级：实现学生查看结果（问题4）
- 低优先级：实现教师手动评分（问题5）
